## JSON

jsonモジュールは、後で使用するために、検索項目からデータを抽出して列挙値にするために使用されます。  データは自己記述的であるため、JSONは日中探査に最適なデータ形式です。  JSONモジュールは項目を抽出してそれらの名前を変更したり、抽出された値に基づいてフィルタリングしたりできます。  JSONモジュール内で直接フィルタリングすると、特定の形式のデータを選択するための非常に高速で直感的な方法が提供されます。

### サポートされているオプション

* `-e <arg>`: “ -e”オプションは、レコード全体ではなく列挙値に作用します。
* `-s`: “ -s”オプションは、厳密モードになっていることをjsonモジュールに通知します。  つまり、項目が見つからない場合はエントリ全体を削除します。

###フィルタリング演算子

JSONモジュールは同等性に基づくフィルタリングを可能にします。  同等（「等しい」または「等しくない」）を指定するフィルタが有効になっている場合、フィルタの指定に失敗したエントリはすべて削除されます。  フィールドが等しくない "！="として指定され、そのフィールドが存在しない場合、そのフィールドは抽出されませんが、エントリは完全にはドロップされません。

| オペレーター | 名 | 説明
|----------|------|-------------
| == | 等しい | フィールドは等しくなければなりません
| != | 等しくない | フィールドは等しくてはいけません
| ~ | サブセット | フィールドはメンバーでなければなりません
| !~ | サブセットではない | フィールドはメンバーであってはいけません

### 例
最も豊富なredditポスターを見つけるために、次の検索では各reddit投稿から "Author"フィールドを新しい列挙値に抽出し、次に各著者の出現回数を数えてテーブルに入れます:

```
tag=reddit json Author | count by Author | table Author count
```

このモジュールは複数のレイヤをJSONエントリに降格させることもできます。  たとえば、テストのために取り込んだShodanのデータでは、エントリから「地域コード」を抽出して、エンドポイントが存在する場所を見つけることができます。  どの州が最も多くのAT&T U-verse顧客を持っているかを知りたい場合は、以下の検索を発行できます:

```
tag=shodan grep "AT&T U-verse" | json location.region_code | count by region_code | table region_code count
```

必要に応じて、フルエントリデータではなく列挙値を操作することもできます。  たとえば、XMLエントリにjsonが含まれているとします:

```
<System><Data>{ "domain": "gravwell.io" }</Data></System>
```

次のコマンドを使用して、XML内からJSONを「Data」という列挙値として抽出し、jsonモジュールを適用してドメイン値を「domain」という別の列挙値に解析します:

```
xml System.Data | json -e Data domain
```
列挙値の名前は、JSON仕様の姓によって派生します。  前の例では、region_codeフィールドが抽出され、出力は "region_code"列挙値に移入されます。  出力列挙値の名前は、 "as"引数で上書きできます。  次の例では、Data列挙値からドメインメンバーを抽出し、それを "dd"という名前の新しい列挙値に割り当てます:

```
json -e Data domain as dd
```
フィルター演算子を使用して、データフィールドを抽出できますが、これはドメインが値「google.com」でない場合のみです。 フィルタは名前の変更と組み合わせることができます。

```
json -e Data domain != "google.com" as dd
```

JSON形式は非常に自由度が高く、Gravwellが通常 '.'や"-"のような区切り文字として扱う文字を含むすべての型の名前を使用できます。  JSON名にそのような文字が含まれている場合は、個々のフィールドを二重引用符で囲んで単一のトークンとして解析してください。  たとえば、このJSON文字列はフィールド名にドット文字を含みます:

```
{ "subfield.op": "stuff", "subfield.type": "int", "subfield.value": 99}
```

An example json module argument to extract the subfield.op member would be:

```
json "subfield.op" as sop
```

同様に、次の入れ子構造を考えてください:

```
{ "fields": { "search-id": 1234, "search-type": "background" } }
```

search-idとsearch-typeにはダッシュ文字が含まれているため、使用時には引用符で囲む必要があります:

```
json fields."search-id" fields."search-type" as type | count by "search-id",type | table "search-id" type count
```
