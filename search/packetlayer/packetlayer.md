## Packet Layer

パケットモジュールは、パケット処理への非常に堅牢なインタフェースを提供しますが、重大な障害が1つあります。  それは健全性を期待しています。  さまざまな操作を呼び出すとき、パケットプロセッサはパケットを正確に分解するために必要な親レイヤを継承します。  パケットクエリがTCPポートを要求すると、パケットプロセッサは必要なサブレイヤを呼び出してTCPレイヤに到達します（イーサネット、802.11q、IPv4、IPv6のいずれであるかにかかわらず）。  パケットレイヤの処理が必要であるが、パケットが不正な形式である、ラップされている、またはまっすぐに破損している可能性がある場合は、「Packet Layer」を使用して指定したレイヤだけを処理できます。

"packetlayer"モジュールの呼び出しは "packet"モジュールと同じですが、最も低いレベルのレイヤーが唯一のレイヤーであることを期待しています。  下記は、これが有用であると思われるいくつかのクエリ例です。  パケットレイヤパーサはまた、エントリまたは列挙値で利用可能なデータがある限りパケットレイヤを抽出し続け、非常に大きなパケットレイヤの塊を処理することを可能にします。  netflowパケットのフラットバイナリファイルはありますか？Packetlayerはそれを処理できます。

### サポートされているオプション

* `-e <arg>`: “ -e”オプションは、レコード全体ではなく列挙値に作用します。  たとえば、パケット処理エンジンは、レイヤ2トンネルの分析など、抽出された値を処理できます。`
* `-m : “-m”オプションは、データが利用できなくなるまで指定されたレイヤーの抽出を続けるようパケットレイヤープロセッサーに指示します（マルチ抽出）。 このオプションは、レイヤー4以上のメッセージを抽出するのに便利です`

### レイヤ4+プロトコル抽出

レイヤ3より上のプロトコルレイヤは、トランスポートを処理するために下位レイヤに依存しているため、多くの場合ストリームベースです。  これは、複数のレイヤ4+メッセージが単一のレイヤ3ペイロードに含まれることを意味します。  パケットレイヤプロセッサを利用してこれらのメッセージを抽出するクエリの例では、パケットモジュールを使用してtcpレイヤペイロードに到達し、パケットレイヤモジュールを使用して複数のmodbusペイロードを抽出します。

```
tag=pcap tcp.Port == 502 tcp.Payload | packetlayer -m -e Payload modbus.Transaction != 0 modbus.Unit | count by Unit | chart count by Unit
```

### ラップパケット転送の抽出

文書化されていないトランスポートプロトコルや怒っている開発者による手作業による転送プロトコルが発生することがあります。  パケットレイヤモジュールを使用しても、健全性を維持できます

```
tag=pcap ipv6.SrcIP udp.Port == 31337 udp.Payload | slice Payload[0:4] as id Payload[4:] as payload2 | packetlayer -e payload2 modbus.Transaction != 0 modbus.Unit | count by Unit | chart count by Unit
```