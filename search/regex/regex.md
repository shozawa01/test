## Regex

正規表現はテキストデータを照合するために正規表現を使用するパイプラインモジュールです。  これは、複雑なパターンを照合し、テキストから列挙可能なフィールドを抽出するための非常に強力な方法です。

正規表現を作成することはこの文書の範囲外ですが、注意すべき重要なことの1つは、(?P<foo> .*)一致したグループを列挙フィールド（この場合は「foo」という名前）に割り当てるスタイル構文です。  これらの列挙フィールドは、分析、図表作成などを実行するのに役立ちます。

たとえば、次の検索では、sshdの承認済みログエントリからmethod、user、およびipが列挙されます。

```
".*sshd.*Accepted (?P<method>\S*) for (?P<user>\S*) from (?P<ip>[0-9]+.[0-9]+.[0-9]+.[0-9]+)"
```

正規表現は非常に長くなる可能性があるため、regexモジュールは`-r`フラグを取ります。  これは正規表現を含むリソースを指定します。  リソースを投入するときは、検索に直接入力する場合と同様に、式全体の周りに「ラッピング引用符」を含まない：例えば`.*ssh.*Accepted`なり`.*ssh.*Accepted`。  これは、通常、引用符は正規表現モジュールに渡される前に検索パーサーによって削除されるためです。

### サポートされているオプション

* `-e <arg>`: “ -e”オプションは、レコード全体ではなく列挙値に作用します。  たとえば、ポート80に向けられていないがHTTPテキストを持つパケットを示すパイプラインは次のようになります。`tag=pcap packet ipv4.DstPort!=80 tcp.Payload | regex -e Payload ".*GET \/ HTTP\/1.1.*"`
* `-r <arg>`: “ -r”オプションは、正規表現ステートメントがリソースファイルにあることを指定します。 
* `-v`: "-v"オプションは、正規表現に一致するエントリをすべてドロップし、一致しないエントリを渡す逆モードで動作するように正規表現に指示します。

Note: 注：特に大きな正規表現をリソースファイルに保存すると、クエリをクリーンアップでき、簡単に再利用できます。 `-r`が指定されている場合、クエリで正規表現を指定しないでください。代わりに、リソースのコンテンツが使用されます。

### インラインフィルタリング

正規表現モジュールはインラインフィルタリングをサポートしており、正規表現モジュール内で直接データを選択解除することができます。  インラインフィルタリングにより、正規表現をアクセラレータと連動させて、処理が必要なデータ量を大幅に減らすこともできます。  インラインフィルタリングは、比較演算子を使用して他のモジュールと同じ方法で実現されます。  等価（ "等しい"、 "等しくない"、 "含む"、 "含まない"）を指定するフィルタが有効になっている場合、フィルタの指定に失敗したエントリはすべて削除されます。  フィールドが等しくない "！="として指定され、そのフィールドが存在しない場合、そのフィールドは抽出されませんが、エントリは完全にはドロップされません。


| オペレーター | 名 | 説明 |
|----------|------|-------------|
| == | 等しい | フィールドは等しくなければなりません
| != | 等しくない | フィールドは等しくてはいけません
| ~ | サブセット | フィールドに値が含まれています
| !~ | サブセットではない | フィールドに値が含まれていません

#### フィルタリング例

```
tag=syslog regex *shd.*Accepted (?P<method>\S*) for (?P<user>\S*) from (?P<ip>[0-9]+.[0-9]+.[0-9]+.[0-9]+)" user==root ip ~ "192.168"
```

### パラメータ構造
```
regex <argument list> <regular expression> <filter arguments>
```
### 検索例
```
tag=syslog grep sshd | regex *shd.*Accepted (?P<method>\S*) for (?P<user>\S*) from (?P<ip>[0-9]+.[0-9]+.[0-9]+.[0-9]+)"
```
